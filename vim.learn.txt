# Insert-mode keys (also work in command-line mode)

`<C-h>` - delete prev char
`<C-W>` - delete previous word
`<C-U>` - delete current line
`<C-O>` - execute normal command and get back to insert mode
`<C-R><r>` - insert the text from register, `<C-R>0` (zero) - paste yanked text, `<C-R>"` - paste the text from the unnamed register
`<C-R>=` - prompt for the expression and insert it 3*0.65=1.95

# Visual mode
`o` - move to other end of the selection
`O` - in block mode - move to other corner on the same line
`c` - in block mode - change block (instead of delete and then insert)

Normal mode
        usage of b, e, ge (and usage of W, B, E, gE)
	w, b, e, ge - letters+digist+underscores surrounded with space or other chars surrunded with space
	W, B, E, gE - anything surrounded with space

        text objects select next object, for example here:
	  <a href="/episodes/show-invisibles/"> Show invisibles: http://vimcasts.org
        it is OK to be on the start of the line to do yi" (yank inner quotes)
	so we can run :norm yi"$p to copy the path and append at the end

	gR - virtual replace mode - will not 'destroy' tabs
		    if you replace the tab in R mode, the whole tab char will be
		    replaced, but in virtual replace mode it will be converted
		    to spaces
	     similarly `gr` will work as `r`, but with virtual replace for tabs

Ex commands:
	  :[range] delete [x] - delete to reg x
	  :[range] yank [x] - yank
	  :[line] put [x] - put reg 'x' contents after line 'line'
	  :[range]copy/move {address} Copy/Move the specified lines to below the line specified by {address}
	  :t - shortcut for :copy
	  :[range]join Join the specified lines

	  :[range]normal {commands} Execute Normal mode {commands} on each specified line
	  :[range]substitute/{pattern}/{string}/[flags] Replace occurrences of {pattern} with {string} on each specified line
	  :[range]global/{pattern}/[cmd] Execute the Ex command [cmd] on all specified lines where the {pattern} matches

	  :h ex-cmd-index

	  :print can be used to preview put/yank/delete/etc
	  :$ - move to the end of file (also used as end line address in ranges)
	       :% also moves to the end (means the whole file)
	  :/<html>/,/<\/html>/p - specify range with patterns
	  :/<html>/+1,/<\/html>/-1p - modify address using offset

	  :t. - duplicate the current line
	  :$t. - copy last line after current line
	  :'<,'>t0 - copy visual selection to the top of the file
	  :'<,'>m$ - move visual selection to the bottom of the file

	  :%normal A; - add ';' to all lines
	       Before executing the specified Normal mode command on each line, Vim
	       moves the cursor to the beginning of the line.
	  :%normal i// - comment out the whole file
	  @: - repeat last ex-command, @@ - repeat again

	  :<Ctrl-R><Ctrl-W> - insert `word` under cursor, <Ctrl-R><Ctrl-a> - `WORD`

	  q: the same as :<Ctrl-F> - command-line window
	  q/ - for search

	  :read !cmd
	  :write !cmd
	  :!cmd -> :write !cmd -> :read
	  !{motion} -> execute command over text selected with motion

	  write normal commands into *.vim file and then execute it with
	  :source file.vim

	  vim file1 file2 file3 - open few files
	  :argo source file.vim - execute the script over them

	  manually populate args:
	  :args file1.js file2.js
	  :args `*.*` - all files in the folder
	  :args `**/*.*` - all files recursively

	  :argdo normal @a - exec marco from `a` on all files in the arglist


	  :args `cat .file.list` - read .file.list and populate args with file
	                           names from the .file.list
	  backticks also work in other cases (can be used instead of file name) >
	       :!cat `ls` will cat all files

	  :h backtick-expansion
	  :e `find . -name ver\\*.c -print`
	  backticks can also be used to expand the vim expression: >
	     :e `=tempname()`
	  The expression can contain just about anything, thus this can also be used to
	  avoid the special meaning of '"', '|', '%' and '#'.  However, 'wildignore'
	  does apply like to other wildcards.


    The :lcd {path} command lets us set the working directory locally for the current
    window. If we create a new tab page and then use the :lcd command to switch
    to another directory, we can then comfortably scope each tab page to a differ-
    ent project. Note that :lcd applies locally to the current window, not to the
    current tab page. If we have a tab page containing two or more split windows,
    we could set the local working directory for all of them by running :windo lcd
    3
    {path} . Check out episode 9 of Vimcasts for more information.

  :%% in the cmd will expand to the current file's dir (this is a custom mapping)
  :find file<Tab> - find file
  :find **/file<Tab> - find recursively

  gf - go to file, also uses `path` option so it will work similar to :find

  gi - insert mode at last change point

marks?

 maybe global, mA sets global mark, so you can jump between files with `A
 useful before doing some :argdo or quickfix-related things
 set a global mark mM, do the thing and get back with `M

visual selection + p

  contents of the "" (unnamed) register is pasted instead of selection
  and the replaced selection goes to the unnamed register
  so we can swap words (or something else) with it:
  add a mark, delete the first, visual select the second, paste, go back, paste

for line visual selection:
    p/P - cursor will be at the beginning of the pasted text
    gp/gP - at the end

Macros:

  qA - append to the macro in register A

  Edit macro:
    :put a  " put text from the 'a' regiser
    ...     " edit it
    "ay     " and yank back to 'a'

    :reg a " check the content of 'a'


  use vimscript in macros, like:
      :let i=1
      qa		" start macro
      I<C-R>=i	" insert i value (1)
      :let i=1+1	" increment i
      q             " stop macro recording
  Now it will insert auto-incrementing number


Learn file / buffer mappings

  noremap <Leader>i :find<SPACE>
  noremap <Leader>I :find <C-R>=expand('%:p:h').'/**/*'<CR>
  " Insert current file's folder
  cnoremap <Leader><Leader>fn <C-r>=expand('%')<CR>
  cnoremap <Leader><Leader>f <C-r>=expand('%:p:h')<CR>
  " will expand %% to current file path
  "cabbr <expr> %% expand('%:p:h')
  cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<CR>
  " list buffers and start completion
  nnoremap <Leader>b :buffer <C-z>
  nnoremap <Leader>B :sbuffer <C-z>
  " list buffers with ls and start completion
  " see: http://www.reddit.com/r/vim/comments/2ueu0g/which_pluginskeybindsetc_significantly_changed/
  nnoremap gb :ls<CR>:buffer<Space>
  nnoremap gB :ls<CR>:sbuffer<Space>

  " Search the last search (@/ - '/' register content, last search text)
  " using vimgrep and show in quickfix
  nnoremap <Leader>z :execute 'vimgrep /'.@/.'/g %'<CR>:copen<CR>

  " recursively vimgrep for word under cursor or selection if you hit leader-star
  nmap <leader>* :execute 'noautocmd vimgrep /\V' . substitute(escape(expand("<cword>"), '\'), '\n', '\\n', 'g') . '/ **'<CR>
  vmap <leader>* :<C-u>call <SID>VSetSearch()<CR>:execute 'noautocmd vimgrep /' . @/ . '/ **'<CR>

  " Grep motions
  nnoremap <silent> g/ :set opfunc=<SID>GrepMotion<CR>g@
  xnoremap <silent> g/ :<C-U>call <SID>GrepMotion(visualmode())<CR>

  " search word under cursor
  " Note: we remap 'gw' here, original gw is similar to gq, see :help gw
  nnoremap gw :Grep '\b<c-r><c-w>\b'<cr> :copen<cr>
  " search for visual selection
  xnoremap <silent> <Leader>w :call <SID>GrepMotion(visualmode())<CR>

Windows
  "rotate windows
  map <leader>wr <C-W>r
  :only - leave only current window, C-W o
  " C-W _||       - maximize height|width
  " C-W =         - make all windows equal
  " C-W x         - exchange with neighbour

  " C-W T         - move window to separate tab
  :tabmove [N] to move tab

  " C-W w         - go to the next window
  " C-W P         - go to preview window
  " C-W z         - close preview window



Quickfix

  :cfdo  - now can be used to execute a command over the quickfix list

  " Quickfix notes:
  "  - (superuseful) :cold / :cnew - display older / newer quckfix state
  "  - location list is the same as quickfix, but local to window (we can
  "    have different location lists for different windows),
  "    lol / lnew for older / newer states

  " :Qargs -> put files from the quickfix to the :args, so can then use :argdo
  " :Qargs | argdo %s/findme/replacement/gc | update
  " See also 'nelstrom/vim-qargs' and QFdo from Vimple (below)
  Plug 'wincent/ferret'

  " Improvements for [I / ]I / [D / ]D - copy their output and
  " put into the quickfix list instead of non-usable window
  " [I / ]I - search for word under cursor in the current file
  " Ilist (use instead of :ilist) - search custom term :Ilist word
  " [D / ]D - search for macro definitions
  " See: https://www.reddit.com/r/vim/comments/1rzvsm/do_any_of_you_redirect_results_of_i_to_the/
  Plug 'romainl/vim-qlist'

  " Having the quickfix list execute :EnMasse to edit the
  " list content and back-sync edits to source files
  Plug 'Wolfy87/vim-enmasse'

  " find and replace occurences in many buffers being aware of the context
  " :Swoop pattern - run for singe buffer
  " :Swoop! pattern - for all buffers
  " For all buffers it is convenient to :CloseSession and :BufOnly and then
  " for example, :args **/*.py to load all python files
  " and then we can review/edit results
  Plug 'pelodelfuego/vim-swoop'

 Manually surround:

         \v'[^']+'
   f[       ^
   c%    \v'°°°°+'    ←── change until the next square bracket, text goes to " reg
(<C-R>") \v'([^'])+'  ←── add (, put the text back with <C-R>", add )

Search / patterns

  \v - very magic - all chars assume special meaning, so we can enter regexps
       without lots of backslashing, we need to backslash only if we want
       something to match literally, like `.` - regexp dot, any char, `\.` - literal dot
       good to search by regexp

  \V - very no magic - good to search by literal string

  Even with \V we still need to escape slashes, if we need to search for an
  url (where we can have many literal slashes), it is convenient to use
  backward search (which uses ? as delimeter):

      http://my.site.com/path/to/the/page

      /\Vhttp:\/\/my.site.com\/path\/to\/the\/page
      ?\Vhttp://my.site.com/path/to/the/page

  This is because forward search still uses / as delimeter (we can add special
  commands at the end of search pattern, like place the cursor after the match
  with `/e` or `?e`
  See :h search-offset, one more example is `;` - perform anther search:

  /enter/;/escape  " search for enter and then for escape

  This is like executing two search commands after each other, except that:
  - It can be used as a single motion command after an operator.
  - The direction for a following "n" or "N" command comes from the first
    search command.
  - When an error occurs the cursor is not moved at all.
  :h //;

  Can be useful as a motion, you do the search and it finds something earlier
  than you wanted, you can 'narrow' it with additional searches
  it can be /search/;/more/;/some more

  Other commands are also useful to shift from the search match:
  [num] or +[num] - num lines down, -[num] - num lines up
  e[+num], e[-num] - num chars right/left of the end of match
  s[+num], s[-num] - num chars right/left of the start of match (same b[+num] / b[-num])

  If we search something and then modify each occurrence, it can be very
  convenient to get into the right position after the search, so we can then
  use `.` (dot) to repeat the change.

  It is also possible to add the modifier for the previous search, just do
  something like `//e+3`.


  Also the literal backslash should always be escaped.
  Automatically escape with <Ctrl-R>=, enter =escape(@x, getcmdtype().'\'),
  the `getcmdtype` returns '\' or '?' depending on forward or backward search,
  so we tell `escape` function what should be escaped - "/ and \" or "? and \"
  the text to search should be in the @x register.

  Use parenthesis to remember the group, then use `\1` to re-use that group in
  the regexp (it will match exactly the same thing as we remembered), like two
  `the`s here:

     I love Paris in the
     the springtime.

     I love Paris in the the springtime.

   /\v<(\w+)\_s+\1>
     |   |    |  |
     |   |    |  +--- the word again, search for remembered (\w) group
     |   |    +------ space or linebreak after the word
     |   +----------- the word
     +--------------- very magic (regexp search, no extra backslashes)

  Groups can also be used in the `substitute`'s replacement.
  Also % can be used to cancel group remembering:

      /\v(%(And|D)rew) (Neil)   " it will capture only two groups,
				" %(And|D) will not be captured
      :%s//\2, \1/g             " so we can just use \1 and \2 here

  /\v<word> - < and > mean word boundaries

  \zs and \ze - to make a match smaller than the whole pattern

    Practical Vim book

    /\vPractical\s\zsVim\ze\sbook   " Search for `Practical Vim book`,
                                    " but match only `Vim`

  Compare with perl patterns :h perl-patterns
  There are also `@xx` forms to define non-matched parts of the pattern:
	0-width match			atom\@=		(?=atom)
	0-width non-match		atom\@!		(?!atom)
	0-width preceding match		atom\@<=	(?<=atom)
	0-width preceding non-match	atom\@<!	(?<!atom)
	match without retry		atom\@>		(?>atom)

    /\v(Practical\s)@<=Vim(\sbook)@=   " Search for `Practical Vim book`,
                                       " but match only `Vim`
				       " it is a positive lookaround assertion
				       " we lookbehind for 'Practical ' and
				       " lookahead for ' book'

    /\v(Theoretical\s)@<!Vim(\sbook)@= " Search for (not)Theoretical Vim book,
                                       " but match only `Vim`
				       " Here we use negative lookbehind
				       " There should be not 'Theoretical '
				       " before the Vim

    Useful tip:
     start entering the search term /sta
     vim highlights the first match, at this point it is possible to
     do <C-R><C-W> to autocomplete the word

      gn - search forward (like n) + visually select the next match
		  if operator is pending - then operate on that match
		  this way do `cgn` to find and change next match
		  then repeat for next matches with `.` (dot)
	It works like this:
	- search for something, for example with `*`
	- do `cgn` - it will change the next match
	- just use `.` to repeat on following matches
	- (no need to press `n`! to move to the next match)

	Other modifying operators are useful too - c, d, ~, gu, gU, g@

      " Repeat change on word
      " Set cursor over a word, <leader>c - change it,
      " now '.' will repeat the change on the next word, n - skip the next word
      nnoremap <leader>c *Ncgn

      Count matches:

      1) with ":s"
         :%s///gn - repeat the last search,
		    (g)lobally, show (n)umber of replaces, don't replace

      2) vimgrep in the current file
         :vimgrep //g %  - vimgrep for the last search in the current file
	                   it will populate the quickfix

    Substitute

       replacement part specials :h sub-replace-special
       \r, \t, \\	- insert carridge return, tab, backslash
       \1, \2, .. \9	- insert sub-match 1-9
       \0 or &		- insert the entire matched
       ~		- use {string} from previous :substitute
       \=		- evaluate the vimscript expression, use result

       For example, we can :s//\=@0/g, here \=@0 will insert the content of
       the register `0`
       With this method we can change the replacement part, for example,
       - yank "text1" into "a
       - do `:s//\=@a/g`
       - move to another place, yank "text2" into "a
       - repeat the `:s//\=@a/g`, now it will use "text2" for replacement

      The `~` replacment and `&` flag can be useful to re-run the substitute
      on the whole file, for example:

      :s/target/replacement/g  - will run on current line
      :%s//~/&                 - run the same on the whole file
				 but the same can be done with `g&`
				 or with `:%&&` (see below)

      To repeat the substitute on the different range, use `:&`
      :'<,'>&   - re-run the substitute on visual selection
      :'<,'>&&  - re-run and use same flags as previous command

      Flags: /g - whole line, /c - confirm
             :%s/../../g -> % + g - act on the whole file

      substiture re-uses the last pattern, so we can do something like :s//"\1"/g
      but we will have an incomplete command in the history, to get the
      complete command, we can do :s/<C-R>//... - use <C-R>/ to actually
      insert the last search

      perform arithmetics during the replacement, for example we select
      numbers and want -1 each of them:

        :%s//\=submatch(0)-1/g

      Swap two words:

	:let swapper={"dog":"man","man":"dog"}
	/\v(<man>|<dog>)
	:%s//\=swapper[submatch(1)]/g

      Execute a block of vimscript - copy it, do `:@"`

      Swap with `Abolish` plugin:

        :%S/{man,dog}/{dog,man}/g

      To replace project-wide, use `:cfdo`

        /Pragmatic\ze Vim        - search
        :vimgrep // **/*.txt     - grep in all files, load to quickfix
	:cfdo %s//Practical/gc          - replace in all files
	:cfdo update

     :[range] global[!] /{pattern}/ [cmd] - execute cmd where pattern match
     `global!` is the same as `vglobal` (inVerted) - execute cmd where pattern doesn't match

     Sort rules inside each css block

       :g/{/ .+1,/}/-1 sort

    :g           - global
    /{/          - pattern, search for each line with '{'
    " .+1,/}/-1" - range, from current line (.) + 1
                   to "search for }" -1 (range can be a search, :help :range)
    sort         - run the :sort command

    We can replace 'sort' with some other command, like '>' to indent the blocks

    :'<,'>g/... - run global on visual selection

      html {
	margin: 0;
	padding: 0;
	border: 0;
	font-size: 100%;
	font: inherit;
	vertical-align: baseline;
      }
      body {
	line-height: 1.5;
	color: black;
	background: white;
      }

    Tags:
      C-] - jump to tag, :tag Name
      gC-] - jump to tag, but if there are multiple
              matches - show the matches first, :tjump name
      C-t - go back

    :make! - make, don't jump to the first error

    location list!
    :lmake, :lgrep, :lvimgrep

    :cold / :cnew

    :compiler name
     active the compiler plugin, will set both 'makeprg' and 'errorformat'
     standard compliers:
     :e $VIMRUNTIME/compiler

    :vim[grep][!] /{pattern}/[g][j] {file}
    {file} can have wildcards - *, ** and ##
    The `##` is to search in the arglist
    so we can do `:vim /some/g *.txt` or `:args *.txt | vim /some/g ##`

    :h cmdline-special
    Also % - current file name, # - alternate file name, #<2 - old 2nd file
    <cword> - word under cursor, <cfile> - file path under cursor, ... there
    are more like this


Plugins

  Surround S" - wrap visual selection into quotes

  The netrw plugin doesn’t just let us explore the file system. We can create
  new files ( :h netrw-% ) or directories ( :h netrw-d ), rename existing ones
  ( :h netrw-rename ), or delete them ( :h netrw-del ). For a demonstration, watch
  episode 15 of Vimcasts. 1

  :Vimdir
  :VimdirR

  :DirDiff dirA dirB

  " ic, ac, iC, aC text object for columns
  " ic / iC based on inner word / WORD (iw / iW),
  " ac / aC - on "a word" / "a WORD" (aw / aW)
  " like vic - select a col / dic - delete a col / cic - change a col
  "      vicI - prepend text to col / vicA - append text
  Plug 'coderifous/textobj-word-column.vim'

  " check comments and help
  Plug 'wellle/targets.vim'

  " :Chmod: Change the permissions of the current file.
  " :Find: Run find and load the results into the quickfix list.
  " :Locate: Run locate and load the results into the quickfix list.
  " :SudoWrite: Write a privileged file with sudo.
  " :W: Write every open window. Handy for kicking off tools like guard.
  Plug 'tpope/vim-eunuch'

  " Replace combinations + smart case (Facility -> Building, facilities -> buildings)
  " :%Subvert/facilit{y,ies}/building{,s}/g
  " Coercion: crs - coerce to snake case, crm - mixed case, crc - camel, cru - upper fooBar (crs)-> foo_bar
  " See also: http://www.reddit.com/r/vim/comments/1weenn/oh_thats_why_abolish_is_useful_subvert/
  Plug 'tpope/vim-abolish'


  Plug 'UltiSnips'

  :Scratch
  maps work from the netrw buffer and git commit buffer:
  == Scratch
  =" Scratch and put from " register + file detect
  =* Scratch and put from * register + file detect
  =f Scratch and set filetype


Unix filters:

There are some vim's filters:
     :vimgrep
     :sort

     tee
     uniq
     cat	Copies input direct to output.
     head	Shows beginning of a file (default 10 lines).
     tail	Shows end of a file (default 10 lines).
     wc	Counts characters, words and lines.
     sort	Sorts input lines.
     grep	Shows lines that match a regular expression.
     tr	Translates or deletes specified character sets.
		     tr '[A-Z]' '[a-z]' - lowercase
		     tr -d '[.,;:]' - remove . , ; :

     sed	Stream editor.
		    sed 's/rich/poor/g'
     uniq	Discards all but one of successive identical lines.
     awk	Highly-programmable field-processing.
	            pattern { action }
		    awk '{ print $1, $5 }' geodata  (for tab-separated table)
		    awk ' $5=="Euro" { print $1 }' geodata
		    totalpop.awk:
			 { sum += $3 }
			 END { print sum }
		     awk -f totalpop.awk geodata

     cut        cut specific columns out of table
     paste
     join
     tac	inversed cat, will print the file backwards

     nl		nl stands for number lines and it does just that.
     pr
     fmt

     expand
     unexpand

     comm
     compress
     fold
     perl
     split
     strings
     zcat
     vim

 https://en.wikipedia.org/wiki/Filter_(software)#Unix


gh - start Select mode
     Like visual, but more like Ms Windows selection using mouse.
     When text is selected, any char entered will replace the selection.
     Convenient for a snippets plugin to replace the placeholders in the
     template.
     :help select-mode

|gr|		gr{char}	2  virtual replace N chars with {char}

|gV|		gV		   don't reselect the previous Visual area
				   when executing a mapping or menu in Select
				   mode

|gv|		gv		   reselect the previous Visual area

|netrw-gx|	gx		   execute application for file name under the
				   cursor (only with |netrw| plugin)

|g@|		g@{motion}	   call 'operatorfunc'



|:#|		:#		same as ":number"
|:&|		:&		repeat last ":substitute"
|:<|		:<		shift lines one 'shiftwidth' left
|:=|		:=		print the cursor line number
|:>|		:>		shift lines one 'shiftwidth' right
|:@|		:@		execute contents of a register
|:@@|		:@@		repeat the previous ":@"
|:Next|		:N[ext]		go to previous file in the argument list
|:append|	:a[ppend]	append text
|:abbreviate|	:ab[breviate]	enter abbreviation
|:abclear|	:abc[lear]	remove all abbreviations
|:aboveleft|	:abo[veleft]	make split window appear left or above
|:all|		:al[l]		open a window for each file in the argument
				list
|:amenu|	:am[enu]	enter new menu item for all modes
|:anoremenu|	:an[oremenu]	enter a new menu for all modes that will not
				be remapped
|:args|		:ar[gs]		print the argument list
|:argadd|	:arga[dd]	add items to the argument list
|:argdelete|	:argd[elete]	delete items from the argument list
|:argedit|	:arge[dit]	add item to the argument list and edit it
|:argdo|	:argdo		do a command on all items in the argument list
|:argglobal|	:argg[lobal]	define the global argument list
|:arglocal|	:argl[ocal]	define a local argument list
|:argument|	:argu[ment]	go to specific file in the argument list
|:ascii|	:as[cii]	print ascii value of character under the cursor
|:autocmd|	:au[tocmd]	enter or show autocommands
|:augroup|	:aug[roup]	select the autocommand group to use
|:aunmenu|	:aun[menu]	remove menu for all modes
|:buffer|	:b[uffer]	go to specific buffer in the buffer list
|:bNext|	:bN[ext]	go to previous buffer in the buffer list
|:ball|		:ba[ll]		open a window for each buffer in the buffer list
|:badd|		:bad[d]		add buffer to the buffer list
|:bdelete|	:bd[elete]	remove a buffer from the buffer list
|:behave|	:be[have]	set mouse and selection behavior
|:belowright|	:bel[owright]	make split window appear right or below
|:bfirst|	:bf[irst]	go to first buffer in the buffer list
|:blast|	:bl[ast]	go to last buffer in the buffer list
|:bmodified|	:bm[odified]	go to next buffer in the buffer list that has
				been modified
|:bnext|	:bn[ext]	go to next buffer in the buffer list
|:botright|	:bo[tright]	make split window appear at bottom or far right
|:bprevious|	:bp[revious]	go to previous buffer in the buffer list
|:brewind|	:br[ewind]	go to first buffer in the buffer list
|:break|	:brea[k]	break out of while loop
|:breakadd|	:breaka[dd]	add a debugger breakpoint
|:breakdel|	:breakd[el]	delete a debugger breakpoint
|:breaklist|	:breakl[ist]	list debugger breakpoints
|:browse|	:bro[wse]	use file selection dialog
|:bufdo|	:bufdo		execute command in each listed buffer
|:buffers|	:buffers	list all files in the buffer list
|:bunload|	:bun[load]	unload a specific buffer
|:bwipeout|	:bw[ipeout]	really delete a buffer
|:change|	:c[hange]	replace a line or series of lines
|:cNext|	:cN[ext]	go to previous error
|:cNfile|	:cNf[ile]	go to last error in previous file
|:cabbrev|	:ca[bbrev]	like ":abbreviate" but for Command-line mode
|:cabclear|	:cabc[lear]	clear all abbreviations for Command-line mode
|:caddbuffer|	:cad[dbuffer]	add errors from buffer
|:caddexpr|	:cadde[xpr]	add errors from expr
|:caddfile|	:caddf[ile]	add error message to current quickfix list
|:call|		:cal[l]		call a function
|:catch|	:cat[ch]	part of a :try command
|:cbuffer|	:cb[uffer]	parse error messages and jump to first error
|:cc|		:cc		go to specific error
|:cclose|	:ccl[ose]	close quickfix window
|:cd|		:cd		change directory
|:cdo|		:cdo		execute command in each valid error list entry
|:cfdo|		:cfdo		execute command in each file in error list
|:center|	:ce[nter]	format lines at the center
|:cexpr|	:cex[pr]	read errors from expr and jump to first
|:cfile|	:cf[ile]	read file with error messages and jump to first
|:cfirst|	:cfir[st]	go to the specified error, default first one
|:cgetbuffer|	:cgetb[uffer]	get errors from buffer
|:cgetexpr|	:cgete[xpr]	get errors from expr
|:cgetfile|	:cg[etfile]	read file with error messages
|:changes|	:changes	print the change list
|:chdir|	:chd[ir]	change directory
|:checkpath|	:che[ckpath]	list included files
|:checktime|	:checkt[ime]	check timestamp of loaded buffers
|:clist|	:cl[ist]	list all errors
|:clast|	:cla[st]	go to the specified error, default last one
|:close|	:clo[se]	close current window
|:cmap|		:cm[ap]		like ":map" but for Command-line mode
|:cmapclear|	:cmapc[lear]	clear all mappings for Command-line mode
|:cmenu|	:cme[nu]	add menu for Command-line mode
|:cnext|	:cn[ext]	go to next error
|:cnewer|	:cnew[er]	go to newer error list
|:cnfile|	:cnf[ile]	go to first error in next file
|:cnoremap|	:cno[remap]	like ":noremap" but for Command-line mode
|:cnoreabbrev|	:cnorea[bbrev]	like ":noreabbrev" but for Command-line mode
|:cnoremenu|	:cnoreme[nu]	like ":noremenu" but for Command-line mode
|:copy|		:co[py]		copy lines
|:colder|	:col[der]	go to older error list
|:colorscheme|	:colo[rscheme]	load a specific color scheme
|:command|	:com[mand]	create user-defined command
|:comclear|	:comc[lear]	clear all user-defined commands
|:compiler|	:comp[iler]	do settings for a specific compiler
|:continue|	:con[tinue]	go back to :while
|:confirm|	:conf[irm]	prompt user when confirmation required
|:copen|	:cope[n]	open quickfix window
|:cprevious|	:cp[revious]	go to previous error
|:cpfile|	:cpf[ile]	go to last error in previous file
|:cquit|	:cq[uit]	quit Vim with an error code
|:crewind|	:cr[ewind]	go to the specified error, default first one
|:cscope|	:cs[cope]       execute cscope command
|:cstag|	:cst[ag]	use cscope to jump to a tag
|:cunmap|	:cu[nmap]	like ":unmap" but for Command-line mode
|:cunabbrev|	:cuna[bbrev]	like ":unabbrev" but for Command-line mode
|:cunmenu|	:cunme[nu]	remove menu for Command-line mode
|:cwindow|	:cw[indow]	open or close quickfix window
|:delete|	:d[elete]	delete lines
|:delmarks|	:delm[arks]	delete marks
|:debug|	:deb[ug]	run a command in debugging mode
|:debuggreedy|	:debugg[reedy]	read debug mode commands from normal input
|:delcommand|	:delc[ommand]	delete user-defined command
|:delfunction|	:delf[unction]	delete a user function
|:diffupdate|	:dif[fupdate]	update 'diff' buffers
|:diffget|	:diffg[et]	remove differences in current buffer
|:diffoff|	:diffo[ff]	switch off diff mode
|:diffpatch|	:diffp[atch]	apply a patch and show differences
|:diffput|	:diffpu[t]	remove differences in other buffer
|:diffsplit|	:diffs[plit]	show differences with another file
|:diffthis|	:diffthis	make current window a diff window
|:digraphs|	:dig[raphs]	show or enter digraphs
|:display|	:di[splay]	display registers
|:djump|	:dj[ump]	jump to #define
|:dl|		:dl		short for |:delete| with the 'l' flag
|:dl|		:del[ete]l	short for |:delete| with the 'l' flag
|:dlist|	:dli[st]	list #defines
|:doautocmd|	:do[autocmd]	apply autocommands to current buffer
|:doautoall|	:doautoa[ll]	apply autocommands for all loaded buffers
|:dp|		:d[elete]p	short for |:delete| with the 'p' flag
|:drop|		:dr[op]		jump to window editing file or edit file in
				current window
|:dsearch|	:ds[earch]	list one #define
|:dsplit|	:dsp[lit]	split window and jump to #define
|:edit|		:e[dit]		edit a file
|:earlier|	:ea[rlier]	go to older change, undo
|:echo|		:ec[ho]		echoes the result of expressions
|:echoerr|	:echoe[rr]	like :echo, show like an error and use history
|:echohl|	:echoh[l]	set highlighting for echo commands
|:echomsg|	:echom[sg]	same as :echo, put message in history
|:echon|	:echon		same as :echo, but without <EOL>
|:else|		:el[se]		part of an :if command
|:elseif|	:elsei[f]	part of an :if command
|:emenu|	:em[enu]	execute a menu by name
|:endif|	:en[dif]	end previous :if
|:endfor|	:endfo[r]	end previous :for
|:endfunction|	:endf[unction]	end of a user function
|:endtry|	:endt[ry]	end previous :try
|:endwhile|	:endw[hile]	end previous :while
|:enew|		:ene[w]		edit a new, unnamed buffer
|:ex|		:ex		same as ":edit"
|:execute|	:exe[cute]	execute result of expressions
|:exit|		:exi[t]		same as ":xit"
|:exusage|	:exu[sage]	overview of Ex commands
|:file|		:f[ile]		show or set the current file name
|:files|	:files		list all files in the buffer list
|:filetype|	:filet[ype]	switch file type detection on/off
|:find|		:fin[d]		find file in 'path' and edit it
|:finally|	:fina[lly]	part of a :try command
|:finish|	:fini[sh]	quit sourcing a Vim script
|:first|	:fir[st]	go to the first file in the argument list
|:fold|		:fo[ld]		create a fold
|:foldclose|	:foldc[lose]	close folds
|:folddoopen|	:foldd[oopen]	execute command on lines not in a closed fold
|:folddoclosed|	:folddoc[losed]	execute command on lines in a closed fold
|:foldopen|	:foldo[pen]	open folds
|:for|		:for		for loop
|:function|	:fu[nction]	define a user function
|:global|	:g[lobal]	execute commands for matching lines
|:goto|		:go[to]		go to byte in the buffer
|:grep|		:gr[ep]		run 'grepprg' and jump to first match
|:grepadd|	:grepa[dd]	like :grep, but append to current list
|:gui|		:gu[i]		start the GUI
|:gvim|		:gv[im]		start the GUI
|:hardcopy|	:ha[rdcopy]	send text to the printer
|:help|		:h[elp]		open a help window
|:helpclose|	:helpc[lose]	close one help window
|:helpfind|	:helpf[ind]	dialog to open a help window
|:helpgrep|	:helpg[rep]	like ":grep" but searches help files
|:helptags|	:helpt[ags]	generate help tags for a directory
|:highlight|	:hi[ghlight]	specify highlighting methods
|:hide|		:hid[e]		hide current buffer for a command
|:history|	:his[tory]	print a history list
|:insert|	:i[nsert]	insert text
|:iabbrev|	:ia[bbrev]	like ":abbrev" but for Insert mode
|:iabclear|	:iabc[lear]	like ":abclear" but for Insert mode
|:if|		:if		execute commands when condition met
|:ijump|	:ij[ump]	jump to definition of identifier
|:ilist|	:il[ist]	list lines where identifier matches
|:imap|		:im[ap]		like ":map" but for Insert mode
|:imapclear|	:imapc[lear]	like ":mapclear" but for Insert mode
|:imenu|	:ime[nu]	add menu for Insert mode
|:inoremap|	:ino[remap]	like ":noremap" but for Insert mode
|:inoreabbrev|	:inorea[bbrev]	like ":noreabbrev" but for Insert mode
|:inoremenu|	:inoreme[nu]	like ":noremenu" but for Insert mode
|:intro|	:int[ro]	print the introductory message
|:isearch|	:is[earch]	list one line where identifier matches
|:isplit|	:isp[lit]	split window and jump to definition of
				identifier
|:iunmap|	:iu[nmap]	like ":unmap" but for Insert mode
|:iunabbrev|	:iuna[bbrev]	like ":unabbrev" but for Insert mode
|:iunmenu|	:iunme[nu]	remove menu for Insert mode
|:join|		:j[oin]		join lines
|:jumps|	:ju[mps]	print the jump list
|:k|		:k		set a mark
|:keepalt|	:keepa[lt]	following command keeps the alternate file
|:keepmarks|	:kee[pmarks]	following command keeps marks where they are
|:keepjumps|	:keepj[umps]	following command keeps jumplist and marks
|:keeppatterns|	:keepp[atterns]	following command keeps search pattern history
|:lNext|	:lN[ext]	go to previous entry in location list
|:lNfile|	:lNf[ile]	go to last entry in previous file
|:list|		:l[ist]		print lines
|:laddexpr|	:lad[dexpr]	add locations from expr
|:laddbuffer|	:laddb[uffer]	add locations from buffer
|:laddfile|	:laddf[ile]	add locations to current location list
|:last|		:la[st]		go to the last file in the argument list
|:language|	:lan[guage]	set the language (locale)
|:later|	:lat[er]	go to newer change, redo
|:lbuffer|	:lb[uffer]	parse locations and jump to first location
|:lcd|		:lc[d]		change directory locally
|:lchdir|	:lch[dir]	change directory locally
|:lclose|	:lcl[ose]	close location window
|:lcscope|	:lcs[cope]      like ":cscope" but uses location list
|:ldo|		:ld[o]		execute command in valid location list entries
|:lfdo|		:lfd[o]		execute command in each file in location list
|:left|		:le[ft]		left align lines
|:leftabove|	:lefta[bove]	make split window appear left or above
|:let|		:let		assign a value to a variable or option
|:lexpr|	:lex[pr]	read locations from expr and jump to first
|:lfile|	:lf[ile]	read file with locations and jump to first
|:lfirst|	:lfir[st]	go to the specified location, default first one
|:lgetbuffer|	:lgetb[uffer]	get locations from buffer
|:lgetexpr|	:lgete[xpr]	get locations from expr
|:lgetfile|	:lg[etfile]	read file with locations
|:lgrep|	:lgr[ep]	run 'grepprg' and jump to first match
|:lgrepadd|	:lgrepa[dd]	like :grep, but append to current list
|:lhelpgrep|	:lh[elpgrep]	like ":helpgrep" but uses location list
|:ll|		:ll		go to specific location
|:llast|	:lla[st]	go to the specified location, default last one
|:llist|	:lli[st]	list all locations
|:lmake|	:lmak[e]	execute external command 'makeprg' and parse
				error messages
|:lmap|		:lm[ap]		like ":map!" but includes Lang-Arg mode
|:lmapclear|	:lmapc[lear]	like ":mapclear!" but includes Lang-Arg mode
|:lnext|	:lne[xt]	go to next location
|:lnewer|	:lnew[er]	go to newer location list
|:lnfile|	:lnf[ile]	go to first location in next file
|:lnoremap|	:ln[oremap]	like ":noremap!" but includes Lang-Arg mode
|:loadkeymap|	:loadk[eymap]	load the following keymaps until EOF
|:loadview|	:lo[adview]	load view for current window from a file
|:lockmarks|	:loc[kmarks]	following command keeps marks where they are
|:lockvar|	:lockv[ar]	lock variables
|:lolder|	:lol[der]	go to older location list
|:lopen|	:lope[n]	open location window
|:lprevious|	:lp[revious]	go to previous location
|:lpfile|	:lpf[ile]	go to last location in previous file
|:lrewind|	:lr[ewind]	go to the specified location, default first one
|:ls|		:ls		list all buffers
|:ltag|		:lt[ag]		jump to tag and add matching tags to the
				location list
|:lunmap|	:lu[nmap]	like ":unmap!" but includes Lang-Arg mode
|:lvimgrep|	:lv[imgrep]	search for pattern in files
|:lvimgrepadd|	:lvimgrepa[dd]	like :vimgrep, but append to current list
|:lwindow|	:lw[indow]	open or close location window
|:move|		:m[ove]		move lines
|:mark|		:ma[rk]		set a mark
|:make|		:mak[e]		execute external command 'makeprg' and parse
				error messages
|:map|		:map		show or enter a mapping
|:mapclear|	:mapc[lear]	clear all mappings for Normal and Visual mode
|:marks|	:marks		list all marks
|:match|	:mat[ch]	define a match to highlight
|:menu|		:me[nu]		enter a new menu item
|:menutranslate| :menut[ranslate] add a menu translation item
|:messages|	:mes[sages]	view previously displayed messages
|:mkexrc|	:mk[exrc]	write current mappings and settings to a file
|:mksession|	:mks[ession]	write session info to a file
|:mkspell|	:mksp[ell]	produce .spl spell file
|:mkvimrc|	:mkv[imrc]	write current mappings and settings to a file
|:mkview|	:mkvie[w]	write view of current window to a file
|:mode|		:mod[e]		show or change the screen mode
|:next|		:n[ext]		go to next file in the argument list
|:new|		:new		create a new empty window
|:nmap|		:nm[ap]		like ":map" but for Normal mode
|:nmapclear|	:nmapc[lear]	clear all mappings for Normal mode
|:nmenu|	:nme[nu]	add menu for Normal mode
|:nnoremap|	:nn[oremap]	like ":noremap" but for Normal mode
|:nnoremenu|	:nnoreme[nu]	like ":noremenu" but for Normal mode
|:noautocmd|	:noa[utocmd]	following commands don't trigger autocommands
|:noremap|	:no[remap]	enter a mapping that will not be remapped
|:nohlsearch|	:noh[lsearch]	suspend 'hlsearch' highlighting
|:noreabbrev|	:norea[bbrev]	enter an abbreviation that will not be
				remapped
|:noremenu|	:noreme[nu]	enter a menu that will not be remapped
|:normal|	:norm[al]	execute Normal mode commands
|:noswapfile|	:nos[wapfile]	following commands don't create a swap file
|:number|	:nu[mber]	print lines with line number
|:nunmap|	:nun[map]	like ":unmap" but for Normal mode
|:nunmenu|	:nunme[nu]	remove menu for Normal mode
|:oldfiles|	:o[ldfiles]	list files that have marks in the ShaDa file
|:omap|		:om[ap]		like ":map" but for Operator-pending mode
|:omapclear|	:omapc[lear]	remove all mappings for Operator-pending mode
|:omenu|	:ome[nu]	add menu for Operator-pending mode
|:only|		:on[ly]		close all windows except the current one
|:onoremap|	:ono[remap]	like ":noremap" but for Operator-pending mode
|:onoremenu|	:onoreme[nu]	like ":noremenu" but for Operator-pending mode
|:options|	:opt[ions]	open the options-window
|:ounmap|	:ou[nmap]	like ":unmap" but for Operator-pending mode
|:ounmenu|	:ounme[nu]	remove menu for Operator-pending mode
|:ownsyntax|	:ow[nsyntax]	set new local syntax highlight for this window
|:pclose|	:pc[lose]	close preview window
|:pedit|	:ped[it]	edit file in the preview window
|:print|	:p[rint]	print lines
|:profdel|	:profd[el]	stop profiling a function or script
|:profile|	:prof[ile]	profiling functions and scripts
|:promptfind|	:pro[mptfind]	open GUI dialog for searching
|:promptrepl|	:promptr[epl]	open GUI dialog for search/replace
|:pop|		:po[p]		jump to older entry in tag stack
|:popup|	:popu[p]	popup a menu by name
|:ppop|		:pp[op]		":pop" in preview window
|:preserve|	:pre[serve]	write all text to swap file
|:previous|	:prev[ious]	go to previous file in argument list
|:psearch|	:ps[earch]	like ":ijump" but shows match in preview window
|:ptag|		:pt[ag]		show tag in preview window
|:ptNext|	:ptN[ext]	|:tNext| in preview window
|:ptfirst|	:ptf[irst]	|:trewind| in preview window
|:ptjump|	:ptj[ump]	|:tjump| and show tag in preview window
|:ptlast|	:ptl[ast]	|:tlast| in preview window
|:ptnext|	:ptn[ext]	|:tnext| in preview window
|:ptprevious|	:ptp[revious]	|:tprevious| in preview window
|:ptrewind|	:ptr[ewind]	|:trewind| in preview window
|:ptselect|	:pts[elect]	|:tselect| and show tag in preview window
|:put|		:pu[t]		insert contents of register in the text
|:pwd|		:pw[d]		print current directory
|:py3|		:py3		execute Python 3 command
|:python3|	:python3	same as :py3
|:py3do|	:py3d[o]	execute Python 3 command for each line
|:py3file|	:py3f[ile]	execute Python 3 script file
|:python|	:py[thon]	execute Python command
|:pydo|		:pyd[o]		execute Python command for each line
|:pyfile|	:pyf[ile]	execute Python script file
|:quit|		:q[uit]		quit current window (when one window quit Vim)
|:quitall|	:quita[ll]	quit Vim
|:qall|		:qa[ll]		quit Vim
|:read|		:r[ead]		read file into the text
|:recover|	:rec[over]	recover a file from a swap file
|:redo|		:red[o]		redo one undone change
|:redir|	:redi[r]	redirect messages to a file or register
|:redraw|	:redr[aw]	force a redraw of the display
|:redrawstatus|	:redraws[tatus]	force a redraw of the status line(s)
|:registers|	:reg[isters]	display the contents of registers
|:resize|	:res[ize]	change current window height
|:retab|	:ret[ab]	change tab size
|:return|	:retu[rn]	return from a user function
|:rewind|	:rew[ind]	go to the first file in the argument list
|:right|	:ri[ght]	right align text
|:rightbelow|	:rightb[elow]	make split window appear right or below
|:rshada|	:rsh[ada]	read from ShaDa file
|:rundo|	:rund[o]	read undo information from a file
|:runtime|	:ru[ntime]	source vim scripts in 'runtimepath'
|:substitute|	:s[ubstitute]	find and replace text
|:sNext|	:sN[ext]	split window and go to previous file in
				argument list
|:sandbox|	:san[dbox]	execute a command in the sandbox
|:sargument|	:sa[rgument]	split window and go to specific file in
				argument list
|:sall|		:sal[l]		open a window for each file in argument list
|:saveas|	:sav[eas]	save file under another name.
|:sbuffer|	:sb[uffer]	split window and go to specific file in the
				buffer list
|:sbNext|	:sbN[ext]	split window and go to previous file in the
				buffer list
|:sball|	:sba[ll]	open a window for each file in the buffer list
|:sbfirst|	:sbf[irst]	split window and go to first file in the
				buffer list
|:sblast|	:sbl[ast]	split window and go to last file in buffer
				list
|:sbmodified|	:sbm[odified]	split window and go to modified file in the
				buffer list
|:sbnext|	:sbn[ext]	split window and go to next file in the buffer
				list
|:sbprevious|	:sbp[revious]	split window and go to previous file in the
				buffer list
|:sbrewind|	:sbr[ewind]	split window and go to first file in the
				buffer list
|:scriptnames|	:scr[iptnames]	list names of all sourced Vim scripts
|:scriptencoding| :scripte[ncoding]	encoding used in sourced Vim script
|:scscope|	:scs[cope]	split window and execute cscope command
|:set|		:se[t]		show or set options
|:setfiletype|	:setf[iletype]	set 'filetype', unless it was set already
|:setglobal|	:setg[lobal]	show global values of options
|:setlocal|	:setl[ocal]	show or set options locally
|:sfind|	:sf[ind]	split current window and edit file in 'path'
|:sfirst|	:sfir[st]	split window and go to first file in the
				argument list
|:simalt|	:sim[alt]	Win32 GUI: simulate Windows ALT key
|:sign|		:sig[n]		manipulate signs
|:silent|	:sil[ent]	run a command silently
|:sleep|	:sl[eep]	do nothing for a few seconds
|:slast|	:sla[st]	split window and go to last file in the
				argument list
|:smagic|	:sm[agic]	:substitute with 'magic'
|:smap|		:smap		like ":map" but for Select mode
|:smapclear|	:smapc[lear]	remove all mappings for Select mode
|:smenu|	:sme[nu]	add menu for Select mode
|:snext|	:sn[ext]	split window and go to next file in the
				argument list
|:snomagic|	:sno[magic]	:substitute with 'nomagic'
|:snoremap|	:snor[emap]	like ":noremap" but for Select mode
|:snoremenu|	:snoreme[nu]	like ":noremenu" but for Select mode
|:sort|		:sor[t]		sort lines
|:source|	:so[urce]	read Vim or Ex commands from a file
|:spelldump|	:spelld[ump]	split window and fill with all correct words
|:spellgood|	:spe[llgood]	add good word for spelling
|:spellinfo|	:spelli[nfo]	show info about loaded spell files
|:spellrepall|	:spellr[epall]	replace all bad words like last |z=|
|:spellundo|	:spellu[ndo]	remove good or bad word
|:spellwrong|	:spellw[rong]	add spelling mistake
|:split|	:sp[lit]	split current window
|:sprevious|	:spr[evious]	split window and go to previous file in the
				argument list
|:srewind|	:sre[wind]	split window and go to first file in the
				argument list
|:stop|		:st[op]		suspend the editor or escape to a shell
|:stag|		:sta[g]		split window and jump to a tag
|:startinsert|	:star[tinsert]	start Insert mode
|:startgreplace| :startg[replace] start Virtual Replace mode
|:startreplace|	:startr[eplace]	start Replace mode
|:stopinsert|	:stopi[nsert]	stop Insert mode
|:stjump|	:stj[ump]	do ":tjump" and split window
|:stselect|	:sts[elect]	do ":tselect" and split window
|:sunhide|	:sun[hide]	same as ":unhide"
|:sunmap|	:sunm[ap]	like ":unmap" but for Select mode
|:sunmenu|	:sunme[nu]	remove menu for Select mode
|:suspend|	:sus[pend]	same as ":stop"
|:sview|	:sv[iew]	split window and edit file read-only
|:swapname|	:sw[apname]	show the name of the current swap file
|:syntax|	:sy[ntax]	syntax highlighting
|:syntime|	:synti[me]	measure syntax highlighting speed
|:syncbind|	:sync[bind]	sync scroll binding
|:t|		:t		same as ":copy"
|:tNext|	:tN[ext]	jump to previous matching tag
|:tabNext|	:tabN[ext]	go to previous tab page
|:tabclose|	:tabc[lose]	close current tab page
|:tabdo|	:tabdo		execute command in each tab page
|:tabedit|	:tabe[dit]	edit a file in a new tab page
|:tabfind|	:tabf[ind]	find file in 'path', edit it in a new tab page
|:tabfirst|	:tabfir[st]	got to first tab page
|:tablast|	:tabl[ast]	got to last tab page
|:tabmove|	:tabm[ove]	move tab page to other position
|:tabnew|	:tabnew		edit a file in a new tab page
|:tabnext|	:tabn[ext]	go to next tab page
|:tabonly|	:tabo[nly]	close all tab pages except the current one
|:tabprevious|	:tabp[revious]	go to previous tab page
|:tabrewind|	:tabr[ewind]	got to first tab page
|:tabs|		:tabs		list the tab pages and what they contain
|:tab|		:tab		create new tab when opening new window
|:tag|		:ta[g]		jump to tag
|:tags|		:tags		show the contents of the tag stack
|:terminal|	:te[rminal]	open a terminal buffer
|:tfirst|	:tf[irst]	jump to first matching tag
|:throw|	:th[row]	throw an exception
|:tjump|	:tj[ump]	like ":tselect", but jump directly when there
				is only one match
|:tlast|	:tl[ast]	jump to last matching tag
|:tmenu|	:tm[enu]	define menu tooltip
|:tnext|	:tn[ext]	jump to next matching tag
|:topleft|	:to[pleft]	make split window appear at top or far left
|:tprevious|	:tp[revious]	jump to previous matching tag
|:trewind|	:tr[ewind]	jump to first matching tag
|:try|		:try		execute commands, abort on error or exception
|:tselect|	:ts[elect]	list matching tags and select one
|:tunmenu|	:tu[nmenu]	remove menu tooltip
|:undo|		:u[ndo]		undo last change(s)
|:undojoin|	:undoj[oin]	join next change with previous undo block
|:undolist|	:undol[ist]	list leafs of the undo tree
|:unabbreviate|	:una[bbreviate]	remove abbreviation
|:unhide|	:unh[ide]	open a window for each loaded file in the
				buffer list
|:unlet|	:unl[et]	delete variable
|:unlockvar|	:unlo[ckvar]	unlock variables
|:unmap|	:unm[ap]	remove mapping
|:unmenu|	:unme[nu]	remove menu
|:unsilent|	:uns[ilent]	run a command not silently
|:update|	:up[date]	write buffer if modified
|:vglobal|	:v[global]	execute commands for not matching lines
|:version|	:ve[rsion]	print version number and other info
|:verbose|	:verb[ose]	execute command with 'verbose' set
|:vertical|	:vert[ical]	make following command split vertically
|:vimgrep|	:vim[grep]	search for pattern in files
|:vimgrepadd|	:vimgrepa[dd]	like :vimgrep, but append to current list
|:visual|	:vi[sual]	same as ":edit", but turns off "Ex" mode
|:viusage|	:viu[sage]	overview of Normal mode commands
|:view|		:vie[w]		edit a file read-only
|:vmap|		:vm[ap]		like ":map" but for Visual+Select mode
|:vmapclear|	:vmapc[lear]	remove all mappings for Visual+Select mode
|:vmenu|	:vme[nu]	add menu for Visual+Select mode
|:vnew|		:vne[w]		create a new empty window, vertically split
|:vnoremap|	:vn[oremap]	like ":noremap" but for Visual+Select mode
|:vnoremenu|	:vnoreme[nu]	like ":noremenu" but for Visual+Select mode
|:vsplit|	:vs[plit]	split current window vertically
|:vunmap|	:vu[nmap]	like ":unmap" but for Visual+Select mode
|:vunmenu|	:vunme[nu]	remove menu for Visual+Select mode
|:windo|	:windo		execute command in each window
|:write|	:w[rite]	write to a file
|:wNext|	:wN[ext]	write to a file and go to previous file in
				argument list
|:wall|		:wa[ll]		write all (changed) buffers
|:while|	:wh[ile]	execute loop for as long as condition met
|:winsize|	:wi[nsize]	get or set window size (obsolete)
|:wincmd|	:winc[md]	execute a Window (CTRL-W) command
|:winpos|	:winp[os]	get or set window position
|:wnext|	:wn[ext]	write to a file and go to next file in
				argument list
|:wprevious|	:wp[revious]	write to a file and go to previous file in
				argument list
|:wq|		:wq		write to a file and quit window or Vim
|:wqall|	:wqa[ll]	write all changed buffers and quit Vim
|:wshada|	:wsh[ada]	write to ShaDa file
|:wundo|	:wu[ndo]	write undo information to a file
|:xit|		:x[it]		write if buffer changed and quit window or Vim
|:xall|		:xa[ll]		same as ":wqall"
|:xmapclear|	:xmapc[lear]	remove all mappings for Visual mode
|:xmap|		:xm[ap]		like ":map" but for Visual mode
|:xmenu|	:xme[nu]	add menu for Visual mode
|:xnoremap|	:xn[oremap]	like ":noremap" but for Visual mode
|:xnoremenu|	:xnoreme[nu]	like ":noremenu" but for Visual mode
|:xunmap|	:xu[nmap]	like ":unmap" but for Visual mode
|:xunmenu|	:xunme[nu]	remove menu for Visual mode
|:yank|		:y[ank]		yank lines into a register
|:z|		:z		print some lines
|:~|		:~		repeat last ":substitute"


vim:tw=78:ts=8:ft=help:norl:
